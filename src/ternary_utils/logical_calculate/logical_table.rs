///*三进制逻辑门查找表声明**
///*2025/5/29**
///  CTLLO
///  平衡三进制摩根定律及逻辑门转换图
///        TOR  <------->  TNOR
///         ^               ^
///         |               |
///         |               |
///         v               v
///       TNAND <------->  TAND


// **非门(TNEG)逻辑表 输入T，输出1；输入0，输出0；输入1，输出T；**
pub const TNEG:[u8; 3]= [0, 2, 1];
// **右偏门(RIGHT_MUX)逻辑表(A+1) 输入T，输出0；输入0，输出1；输入1，输出T；**
pub const RIGHT_MUX:[u8; 3]= [1, 2, 0];
// **左偏门(LEFT_MUX)逻辑表(A-1)  输入T，输出1；输入0，输出T；输入1，输出0；**
pub const LEFT_MUX: [u8; 3]= [2, 0, 1];
// **最大门(MAX_MUX)逻辑表max(A,0) A与0比较，较大的输出 **
pub const MAX_MUX:[u8; 3]= [0, 1, 0];
// **最小门(MIN_MUX)逻辑表min(A,0) A与0比较，较小的输出 **
pub const MIN_MUX:[u8; 3]= [0, 0, 2];

// **或门(TOR)逻辑表MAX(A,B) 有1出1、双T出T、其余为0 **
pub const TOR:[[u8; 3];3]= [
    [0, 1, 0],
    [1, 1, 1],
    [0, 1, 2],
];
// **与门(TAND)逻辑表MIN(A,B) 有T出T、双1出1、其余为0 **
pub const TAND:[[u8; 3];3]= [
    [0, 0, 2],
    [0, 1, 2],
    [2, 2, 2],
];
// **或非门(TNOR)逻辑表 有1出T、双T出1、其余为0 **
pub const TNOR:[[u8; 3];3]= [
    [0, 2, 0],
    [2, 2, 2],
    [0, 2, 1],
];
// **与非门(TAND)逻辑表 有T出1、双1出T、其余为0 **
pub const TNAND:[[u8; 3];3]= [
    [0, 0, 1],
    [0, 2, 1],
    [1, 1, 1],
];
// **异或门(TXOR)逻辑表 双T及双1出T、1T及T1出1、其余为0 **
pub const TXOR:[[u8; 3];3]= [
    [0, 0, 0],
    [0, 2, 1],
    [0, 1, 2],
];
// **同或门(TXNOR)逻辑表 双T及双1出1、1T及T1出T、其余为0 此门相当于乘法表用于相乘处理 **
pub const TXNOR:[[u8; 3];3]= [
    [0, 0, 0],
    [0, 1, 2],
    [0, 2, 1],
];


// **加和(TSUM)逻辑表 当为TT、01、10时出1，当为11、0T、T0时出T，其余为0 此门用于半加器的加和位处理 **
pub const TSUM:[[u8; 3];3]= [
    [0, 1, 2],
    [1, 2, 0],
    [2, 0, 1],
];
// **共识(TCONS)逻辑表 双T出T、双1出1、其余为0 此门用于半加器的进位处理 **
pub const TCONS:[[u8; 3];3]= [
    [0, 0, 0],
    [0, 1, 0],
    [0, 0, 2],
];
// **调和(TANY)逻辑表 当为TT、0T、T0时出T，当为11、01、10时出1，其余为0 此门用于全加器进位处理 **
pub const TANY:[[u8; 3];3]= [
    [0, 1, 2],
    [1, 1, 0],
    [2, 0, 2],
];

// **非零门(TPOZ)逻辑表 当为T1、0T、T0、TT时出T，当为1T、01、10、11时出1，双0出0 此门用于检测其最高位的正负性，出T为负数，出1为正数，出0则0 **
pub const TPOZ:[[u8; 3];3]= [
    [0, 1, 2],
    [1, 1, 1],
    [2, 2, 2],
];
// **比较门(TCMP)逻辑表 （a=b）输出 0、 （a > b）输出 +1、(a < b)输出 -1**
pub const TCMP:[[u8; 3];3]= [
    [0, 2, 1],
    [1, 0, 1],
    [2, 2, 0],
];
// **除法门(TDIV)逻辑表 零不能作为除数，3属于非法值**
pub const TDIV:[[u8; 3];3]= [
    [3, 0, 0],
    [3, 1, 2],
    [3, 2, 1],
];

// **全加器和(TFULLSUM) 逻辑表**
pub const TFULLSUM:[[[u8; 3];3];3] = [
    [
        [0, 1, 2],
        [1, 2, 0],
        [2, 0, 1],
    ],
    [
        [1, 2, 0],
        [2, 0, 1],
        [0, 1, 2],
    ],
    [
        [2, 0, 1],
        [0, 1, 2],
        [1, 2, 0],
    ],
];
// **全加器进位(TFULLCONS) 逻辑表**
pub const TFULLCONS:[[[u8; 3];3];3] = [
    [
        [0, 0, 0],
        [0, 1, 0],
        [0, 0, 2],
    ],
    [
        [0, 1, 0],
        [1, 1, 0],
        [0, 0, 0],
    ],
    [
        [0, 0, 2],
        [0, 0, 0],
        [2, 0, 2],
    ],
];
// **三与门(T3AND)逻辑表 有T出T、三1出1、其余为0 **
pub const T3AND:[[[u8; 3];3];3] = [
    [
        [0, 0, 2],
        [0, 0, 2],
        [2, 2, 2],
    ],
    [
        [0, 0, 2],
        [0, 1, 2],
        [2, 2, 2],
    ],
    [
        [2, 2, 2],
        [2, 2, 2],
        [2, 2, 2],
    ],
];
// **三或门(T3AND)逻辑表 有1出1、三T出T、其余为0 **
pub const T3OR:[[[u8; 3];3];3] = [
    [
        [0, 1, 0],
        [1, 1, 1],
        [0, 1, 0],
    ],
    [
        [1, 1, 1],
        [1, 1, 1],
        [1, 1, 1],
    ],
    [
        [0, 1, 0],
        [1, 1, 1],
        [0, 1, 2],
    ],
];
